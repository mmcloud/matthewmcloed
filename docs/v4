Harness Backstage Plugin Architecture and SEI Metrics Integration

Current Plugin Architecture and Key API Usage

The official Harness Backstage plugins are organized as a set of front-end modules (one per Harness product area) within a monorepo ￼ ￼. The CI/CD plugin (for Harness NextGen) is a representative example: it adds a tab in Backstage where developers can see recent pipeline executions for a service ￼ ￼. Under the hood, these plugins do not implement a custom backend; instead they leverage Backstage’s proxy to call Harness APIs. The Harness CI/CD plugin connects a Backstage service to a Harness project and fetches the latest ~50 pipeline executions (builds or deployments) from that project ￼. It displays execution details – status, timestamps/duration, commit info (for CI pipelines), and deployed services (for CD pipelines) – in a table. The UI also supports filtering by pipeline and even provides a “Run Pipeline” action to re-trigger failed executions ￼ ￼. These features are implemented by calling Harness NextGen APIs for pipeline listings and execution details via the proxy (and invoking the pipeline run API for reruns). The exact API endpoints are abstracted behind the proxy, but they correspond to Harness’s NextGen Pipeline APIs. For example, the plugin uses the Harness project and pipeline identifiers (parsed from configured URLs) to retrieve execution history and to trigger pipeline re-execution.

Notably, each Harness plugin follows a similar structure: a React component (EntityHarness...Content) rendered in an entity page tab, which on mount calls the Harness REST endpoints through the proxy and then renders data. There is no separate microservice – the Backstage frontend makes requests to */api/proxy/harness/* routes, which the Backstage backend forwards to Harness’s SaaS API. This design keeps the plugin lightweight and within Backstage’s single-page app. Harness provides open-source plugins for other modules (Feature Flags, Chaos, SRM, etc.) that follow this same pattern. Each plugin is responsible for parsing specific Harness URLs/IDs from annotations and hitting the corresponding Harness API endpoints (e.g. listing feature flags, chaos experiments, cloud cost data, etc.) with the appropriate module-specific REST paths. All of them rely on the Harness NextGen API (the same underlying platform APIs that Harness UI uses), authenticated via API key. In summary, the architecture is front-end driven, using Backstage’s proxy to securely communicate with Harness’s endpoints, and the UI components are responsible for data fetching and rendering. This keeps integration simple but means any new Harness data (like SEI metrics) would likely be implemented as another plugin module in the same fashion for consistency.

Authentication and Service Mapping Mechanism

Authentication: The Harness Backstage plugins authenticate to Harness using a Personal Access Token (PAT) or Service Account token configured in Backstage. In a self-hosted Backstage setup, you add an entry to app-config.yaml under the proxy settings, providing the Harness base URL and an API key header. For example:

proxy:
  '/harness/prod':
    target: 'https://app.harness.io/'
    headers:
      'x-api-key': '<YOUR PAT/SAT>'

This config ensures all requests to /harness/prod/** are forwarded to the Harness SaaS endpoint with the required API key ￼. The plugin reads this token from the proxy config and uses it on every API call ￼. Harness’s docs note that the API key’s user (or service account) should have at least Project View, Pipeline View, and Execute permissions for the relevant projects ￼. This is required to fetch pipeline data and trigger runs. In Harness’s own IDP (their Backstage-based portal), this proxy is pre-configured and can piggyback on the user’s Harness session (no separate secret needed) ￼ ￼. But for standalone Backstage usage, the PAT in x-api-key is the authentication mechanism. All Harness plugins share this same proxy (/harness/prod), reusing the base URL and API key configuration for simplicity ￼ ￼. This means once you set up the proxy with the token, it covers CI/CD, SRM, Feature Flags, etc., and any new Harness plugin can use it as well.

Service Mapping: The integration between Backstage’s catalog and Harness entities is done through entity annotations. Each Backstage component (usually of kind Component, type service) that you want to link to Harness must include specific annotations in its catalog-info.yaml. The Harness CI/CD plugin originally used an older single annotation (harness.io/project-url for the Harness project) along with optional IDs, but it now supports a richer mapping. Specifically, you can list pipeline URLs and service URLs with labels. For example:

metadata:
  annotations:
    harness.io/pipelines: |
      CI: <harness_ci_pipeline_url>
      CD: <harness_cd_pipeline_url>
    harness.io/services: |
      serviceA: <harness_service_url>

In this example, “CI” and “CD” are labels that will appear in a drop-down on the Backstage plugin UI, allowing the user to filter or switch context between the linked pipelines ￼ ￼. The values (<harness_pipeline_url> etc.) are the URLs one would copy from the Harness UI – they contain the account, org, project, and pipeline identifiers. The plugin code parses these URLs to extract the needed identifiers (such as projectId, pipelineId, serviceId) for API calls. If no specific pipelines are annotated, the plugin will default to showing all pipelines in the linked Harness project ￼ ￼. Similarly, the Harness Service Reliability (SRM) plugin uses the harness.io/services annotation to know which Harness monitored service (SLOs and error budgets) to display ￼ ￼, and the IACM (Infra as Code) plugin uses harness.io/workspace-url to map a Backstage service to a Harness IaC workspace ￼ ￼. In all cases, the presence of the annotation triggers the plugin’s availability (via an isHarness...Available check) ￼ ￼. This mapping strategy cleanly ties Backstage components to Harness resources without hard-coding any names – it’s configurable per service via catalog data.

In summary, service mapping is handled by explicit annotations that store Harness URLs/IDs, and the plugin uses those to fetch the right data. This approach means that to integrate a new Harness module (like SEI), one would introduce a new annotation (or reuse an existing one if appropriate) to identify the relevant entity in Harness (e.g. a team or project for metrics). It also ensures the plugin only appears on entities that have been annotated, avoiding empty tabs for services that aren’t using Harness.

Visualizing Pipeline Data in Backstage (CI/CD Plugin Example)

Once authentication and mapping are in place, the Harness CI/CD plugin provides an in-portal view of pipeline execution history. The implementation is focused on surfacing key pipeline information in a compact form. By default it fetches the latest 50 executions across the mapped pipelines in the Harness project ￼. The UI presents a table listing each execution with: the pipeline name or identifier, execution status (Succeeded, Failed, Running, etc.), the start time and duration, and contextual details like the Git commit or trigger that started the run. In case of CD pipelines, it also shows which Service was deployed (since Harness CD has the concept of services and environments) ￼. This mirrors what one would see in Harness’s UI “Executions” page, but filtered to just the pipelines relevant to the Backstage service. If multiple pipelines are linked (via labels like “CI”/“CD”), the plugin UI typically provides a dropdown or tabs to switch between them, so teams can view builds vs deployments separately if desired ￼.

A notable feature is the ability to trigger pipeline re-execution from Backstage. The plugin includes a “Run Pipeline” button (for CI pipelines) or a “Re-run” action on failed runs, which calls the Harness Pipeline Execution API to start a new run ￼. This uses the same x-api-key authentication, effectively letting developers kick off builds or deployments without leaving Backstage. (Internally, it likely posts to an endpoint like /pipeline/api/pipelines/{id}/start or uses the Harness GraphQL if available – the specifics are abstracted from the user.) For safety, this feature can be turned off via config if an organization’s Backstage lacks proper RBAC controls ￼.

The key API calls the CI/CD plugin makes include: retrieving the list of pipeline executions (possibly via a Harness REST endpoint that returns executions for given pipeline IDs or project), retrieving details for each execution (to get commit info, etc., if not already in the list response), and posting a pipeline run request for the re-run action. All these calls are made to Harness’s NextGen API (the same that the Harness web app uses). For example, to get executions the plugin might call an endpoint such as:

GET /pipeline/api/pipelines/{pipelineIdentifier}/executions?accountIdentifier=<acct>&orgIdentifier=<org>&projectIdentifier=<proj>&pageSize=50

(This is an illustrative pattern; the actual API may differ in path.) The plugin uses the project and pipeline identifiers parsed from the annotation URLs to construct these requests. Likewise, the re-run is done via a POST to a pipeline execution API (Harness offers a “StartExecution” or retry API to trigger pipelines via API ￼). The Harness Developer Hub documentation indicates no separate secret or OAuth flow is needed for these calls because they are authenticated by the provided API key and occur server-to-server via the proxy ￼ ￼.

In effect, the plugin is a thin UI layer over Harness’s APIs: it visualizes pipeline data (including statuses and metrics like run duration), and delegates actions (like starting a pipeline) to Harness. This provides a unified developer experience – teams can see recent builds/deploys for a service and even deploy or rebuild from within Backstage ￼. All of this is accomplished with straightforward REST calls, thanks to Harness’s API-first approach. The plugin does not currently do heavy data processing itself; it relies on Harness to provide the needed info (e.g., the plugin might simply display raw fields from the API like status, timestamps, etc., possibly with minimal formatting).

Extending the Plugin for SEI Metrics (DORA & Rework)

With Harness Software Engineering Insights (SEI) on the roadmap ￼, an opportunity arises to integrate engineering performance metrics (like DORA metrics and code rework metrics) into Backstage. To support SEI metrics retrieval, the existing Harness plugin project can be extended or forked to create a new plugin module dedicated to SEI. Given the current modular structure (one plugin per Harness product), the cleanest approach is to implement a new Backstage plugin (e.g. backstage-plugin-harness-sei) rather than shoehorning metrics into the CI/CD plugin. This new plugin would reuse much of the existing framework: it would leverage the same proxy configuration (and API key) and would map Backstage entities to the relevant Harness SEI context via annotations.

Proposed integration strategy: Harness SEI primarily tracks metrics at the team or project level (such as DORA metrics across multiple pipelines, and SCM metrics for code activity). We’d introduce a custom annotation, for example:

harness.io/sei-team-id: <TeamIdentifier>

or

harness.io/sei-dashboard-url: "<link to Harness SEI page>"  

This annotation would tell the plugin which team or scope’s metrics to fetch for a given service. In cases where each Backstage service is owned by one team, you might use a team-based mapping (so the service shows that team’s DORA metrics). Alternatively, if metrics are organized by project or application, the annotation could reference a Harness project. The key is that we need an identifier to pass to the SEI API – Harness’s SEI APIs allow filtering by team and by project ￼. For instance, Harness provides an Insights Export API where you POST /v2/insights/teams/reports with a JSON payload specifying a teamRefId (team ID) and date range ￼ ￼. This returns productivity and efficiency metrics (the efficiency metrics are essentially DORA metrics like Lead Time, Deployment Frequency, MTTR, etc.) ￼. The new plugin can call this endpoint (via the proxy with the same x-api-key auth) to retrieve the metrics data.

Harness’s documentation notes that the Insights API returns a CSV file by default ￼. In practice, the Backstage plugin could use the CSV export or look for a JSON response option. If only CSV is available, the plugin’s backend (or the frontend, if feasible) might need to parse the CSV to extract metrics. A more elegant approach, if supported, is to call the API with format=json or use any forthcoming SEI endpoints that return structured data. Since SEI 2.0 is relatively new, the plugin development might coincide with Harness exposing richer APIs for dashboards. In any case, the plugin would likely fetch metrics such as: Deployment Frequency, Lead Time for Changes, Change Failure Rate, Mean Time to Restore (the four DORA metrics), and possibly Rework metrics (e.g. “Rework Ratio” or lines of code churned) from source control data ￼. Harness’s SEI defines Rework Metrics as the amount of code changes to existing code (a measure of churn/quality) ￼. These could be included as additional data points to display alongside DORA metrics to give a fuller picture of engineering efficiency vs. quality.

UI integration: Once retrieved, these metrics could be shown on a Backstage service page either as a dedicated “Engineering Metrics” tab or as a section in an existing overview tab. Given Backstage’s flexibility, one could add a new EntityLayout.Route for “Engineering Insights” that renders an EntityHarnessSeiContent component (similar to how the other plugins add their tab) ￼ ￼. This component can display the metrics in a developer-friendly format – for example, showing the DORA metrics values with visual indicators (like trending up/down arrows or gauges) and perhaps small charts for trends over time. It might also show “Rework” as a percentage of code changes that are modifications vs. new code, or other productivity metrics like PR throughput, depending on what data is available via the API. Since Backstage already has a Tech Insights plugin (for general scorecards), we could either feed the Harness data into Tech Insights, or simply render our own UI. Initially, a self-contained UI in the plugin might be quicker: e.g., four stat cards for the DORA metrics and a table or chart for rework metrics.

Reusing vs. new plugin: Reusing the existing codebase is recommended – the Harness plugins share common patterns and even configuration. We can likely clone the structure of an existing module (like harness-ci-cd or harness-srm) and adapt it for SEI. This means creating a new plugin package that defines isHarnessSeiAvailable (checking for our new annotation) and an EntityHarnessSeiContent component. We can reuse the same proxy (/harness/prod) since the base URL (Harness platform) and auth method (API key) are the same for SEI. One just needs to ensure the API key used has permission to access SEI data – typically, an account-level API key with the “SEI Viewer” or similar rights. (Harness’s docs suggest generating a token for the Insights API ￼, which is the same process as other API keys, so the existing token likely works if the user has access to SEI.) Because the harness/backstage-plugins repo is open-source and welcomes contributions, a clean implementation of a new SEI plugin could potentially be upstreamed. However, if timing is an issue, maintaining a fork might be necessary since SEI support is marked “Coming soon” in the official roadmap ￼.

One design consideration is whether to aggregate data by service or by team. If a Backstage service maps directly to a single Harness team’s metrics, the annotation approach (one team ID per service) works well. In organizations where one service’s DORA metrics are scattered (e.g. multiple teams contribute or multiple pipelines), it might be beneficial to allow multiple identifiers in the annotation (similar to how pipelines annotation allows listing CI and CD separately). For example, harness.io/sei-teams: | TeamA: <id1> TeamB: <id2>. This could allow showing comparative metrics or an average. But this adds complexity and is probably not the first iteration; initially focusing on a 1:1 mapping (one Backstage component -> one set of metrics) is simplest.

Recommendations and Design Improvements

1. Leverage Existing Patterns and Proxy: The extension for SEI should reuse the existing plugin infrastructure. Use the same proxy configuration and fetch data via the Backstage proxy with the API key ￼ ￼. This avoids implementing new auth flows. Ensure the Backstage backend has the proxy plugin enabled (most Backstage apps do, but some may need to add the @backstage/plugin-proxy-backend) ￼ ￼. Reusing the proxy means minimal changes to configuration for users – no new secrets, just possibly updating the token’s permissions if needed.

2. Modularize Common Code: As more Harness plugins are added (SEI and others), consider refactoring any common logic into a shared package. For example, parsing Harness URLs to identifiers, constructing API request URLs, or formatting status indicators might be similar across CI/CD, SRM, and SEI. If the current repo doesn’t already have a utility module, creating one (e.g. harness-common) could reduce duplication. This would make it easier to maintain the integration points. For instance, if Harness changes its domain or API path, it could be updated in one place. It would also allow a consistent approach to error handling and loading states in the UI for all plugins.

3. Data Caching or Backend Processing: The SEI metrics data might be heavier to compute (especially if we fetch a large time range or many metrics). While the initial approach can be to fetch on the fly in the frontend, we might explore adding a lightweight backend plugin in the future for caching or processing. Backstage allows creating backend plugins (NodeJS APIs) that the frontend can call. For example, a backend plugin could periodically pull SEI metrics (maybe nightly) and store them, or convert CSV to JSON before sending to the UI. This could improve performance and allow more complex analysis (like computing trends). Given that the current Harness plugins are entirely front-end, adding a backend is optional – but it’s a potential improvement if real-time queries prove slow.

4. Integrate with Service Catalog semantics: We should ensure that whatever annotation or mapping we choose aligns with Backstage usage. If Backstage already has a concept of “team” (via ownership), we might consider using the owner field to look up metrics, but that would require mapping Backstage owner to Harness team, which may not be trivial. An explicit annotation (harness.io/sei-team) is more direct. We should document clearly how to obtain the required team or project ID from Harness (similar to how the CI/CD plugin documentation explains copying the project URL or pipeline URL from Harness UI ￼). This will make adoption easier. It might be helpful to support both a “team ID” and a “project” mode. For example, if an org hasn’t defined SEI teams, they might want DORA metrics per Harness project instead. We could allow an annotation like harness.io/sei-project: <projectId> as an alternative. The plugin could accept either a team ID or project and adjust API calls accordingly (the Insights API supports a projectIdentifier filter ￼). This flexibility would broaden the usefulness of the plugin.

5. User Experience and Visualization: DORA metrics and rework metrics should be displayed in a concise, comprehensible way. It’s recommended to use visual cues – e.g., green/red coloring for healthy vs. concerning values (a high change failure rate could be red), and maybe small sparkline charts to show trends over time (if data for multiple intervals is fetched). Since Backstage is a React app, we can use libraries like Chart.js or Recharts, or even Backstage’s built-in charts if available. Another improvement could be to link back to Harness: e.g., if the user clicks on a metric card, it could navigate to the Harness SEI dashboard for that team (via the URL if provided in annotation). This follows the pattern in other Harness plugins where you can “jump to Harness” for deeper details ￼ ￼. Providing that integration (deep linking) would complete the loop between Backstage and Harness.

6. Keep Up with Harness API updates: Since SEI is new, we should watch for official Harness SEI plugin release or API changes. The moment Harness releases an official Backstage plugin for SEI (or updates the API to return JSON), it might be better to adopt or adapt that rather than maintaining a long-term fork. The design we choose now should be modular enough to swap out the data source if needed. For instance, if currently we use the CSV export API ￼, but later a proper metrics API becomes available, we should encapsulate the data-fetching logic so it can be changed without rewriting the UI.

In conclusion, the Harness Backstage plugin is built in a modular, extensible way, making it straightforward to add support for Software Engineering Insights. By reusing the proxy authentication method ￼ and following the established annotation pattern ￼, we can integrate DORA and rework metrics into Backstage with minimal friction. Our recommendation is to create a new plugin component for SEI metrics, use a clear annotation for mapping services to metrics scope, and ensure the design remains consistent with the existing Harness plugins for a seamless user experience. This approach provides immediate value (bringing key engineering performance indicators next to each service in the catalog) while aligning with the expected official support once Harness delivers the SEI plugin (as indicated on their roadmap) ￼.

Sources:
	•	Harness CI/CD Backstage Plugin – README and Setup Instructions ￼ ￼
	•	Harness Developer Hub – Plugin Documentation (CI/CD and SRM) ￼ ￼ ￼
	•	Roadie Plugin Guide – Harness IACM Plugin (example of config and annotation) ￼ ￼
	•	Harness SEI API Documentation – Exporting DORA and Productivity Metrics ￼ ￼
	•	Harness Plugins Repository – Project README and Roadmap ￼ ￼